' Gambas class file

Inherits _HTMCONSTS

Export


''http://www.w3schools.com/js/js_htmldom.asp

''Propiedades publicas
'****Info del Objeto
Property Read className As String
Property Read classVersion As String
Property Read classDescription As String
Property Read classVendor As String
Private $classVersion As String = "1.0.0"
Private $classDescription As String = "Extended JSDOM (http://www.w3schools.com/js/js_htmldom.asp) Implementation for Gambas Language writed in pure Gambas."
Private $classVendor As String = "Jalonsor. (PierreNoDoyUna). https://github.com/jalonsor"

'****Del DOM
Property innerHTML As String
Private $innerHTML As String
Property text As String
Private $text As String

Private $strHtml As String '' *** Esta es la que se usa para el parser
Private $removeBlankText As Boolean = False

''*** INICIO Time Measurements
Private $swLoadedByFile As Boolean = False
Private $timeStartLoadString As Date
Private $timeEndLoadString As Date
Property Read timeLoadString As Integer
Private $timeStartLoadFile As Date
Private $timeEndLoadFile As Date
Property Read timeLoadFile As Integer
Private $timeStartBuildDOM As Date
Private $timeEndBuildDOM As Date
Property Read timeBuildDOM As Integer
''*** FIN Time Measurements

''**** INICIO Coleccion para busquedas
Private $all As New HTMElement[]
Private $ids As New Collection '' HTMElement[]
Private $tagNames As New Collection '' HTMElement[][]
Private $names As New Collection '' HTMElement[][]
Private $classNames As New Collection '' HTMElement[][]
''**** FIN Coleccion para busquedas

Private $stackElm As New HTMElement[] 		''To keep nesting track

Public document As HTMDocument = Me

Public readyState As Boolean = False      'Returns the(loading)status Of the document 3
Public strictErrorChecking As Boolean = False     'Returns If Error checking Is Enforced 3

Public root As HTMElement = Null 		'Same as documentElement ---> '<html>'
Public documentElement As HTMElement = Null      'Returns the < html > HTMElement 3
Public head As HTMElement = Null      'Returns the < head > HTMElement 1
Public favicon As HTMElement = Null 		'<link rel="shortcut icon" type="image/png" href="http://eg.com/favicon.png"/>
Public title As HTMElement = Null      'Returns the < title > HTMElement 1
Public body As HTMElement = Null      'Returns the < body > HTMElement 1
Public cookie As New HTMElement[]      'Returns the document 's cookie 	1 (**)NOT IMPLEMENTED as JavaScript is not implemente in this DOM tree.
Public anchors As New HTMElement[]      'Returns all < a > HTMElements that have a name attribute 1
Public applets As New HTMElement[]      'Returns all < applet > HTMElements(Deprecated In HTML5)1
Public embeds As New HTMElement[]      'Returns all < embed > HTMElements 3
Public forms As New HTMElement[]      'Returns all < form > HTMElements 1
Public images As New HTMElement[]      'Returns all < img > HTMElements 1
Public links As New HTMElement[]      'Returns all < area > And < a > HTMElements that have a href attribute 1
Public metas As New HTMElement[]      'Returns all < meta > HTMElements
Public linkRels As New HTMElement[]      'Returns all < link > HTMElements
Public scripts As New HTMElement[]      'Returns all < script > HTMElements 3
Public comments As New HTMElement[]      'Returns all <!-- .. --> HTMElements 3
Public texts As New HTMElement[]      'Returns all Texts HTMElements 3


Public baseURI As String      'Returns the absolute base URI Of the document 3
Public doctype As String      'Returns the document 's doctype 	3
Public documentMode As String     'Returns the mode used by the browser 3
Public documentURI As String      'Returns the URI Of the document 3
Public domain As String       'Returns the domain name Of the document server 1
Public domConfig As String 'Obsolete.Returns the DOM configuration 3
Public implementation As String     'Returns the DOM implementation 3
Public inputEncoding As String      'Returns the document 's encoding (character set) 	3
Public lastModified As String      'Returns the Date And Time the document was updated 3
Public referrer As String      'Returns the URI Of the referrer(the linking document)1
Public URL As String      'Returns the complete URL Of the document 1


''****** INICIO Constructores y Propiedades
Public Sub _new(Optional strHtml As String = Null, Optional removeBlankText As Boolean = False)
  $removeBlankText = removeBlankText
  
  If strHtml <> Null Then
    $swLoadedByFile = False
    $timeStartLoadString = Now
    $innerHTML = strHtml
    $strHtml = strHtml
    $timeEndLoadString = Now
    initDom
  Endif
End

Public Sub _free() ''***Se invoca al destruir el objeto
  clearDom  ''Liberar Objetos y Referencias
End


Private Function innerHTML_Read() As String
  Return $innerHTML
End

Private Sub innerHTML_Write(Value As String)
  $swLoadedByFile = False
  $timeStartLoadString = Now
  $innerHTML = Value
  $strHtml = Value
  $timeEndLoadString = Now
  initDom
End

Private Function text_Read() As String
  Return $Text
End

Private Sub text_Write(Value As String)
  $text = Value
  $innerHTML = Value
  $strHtml = Value
  initDom
End

Private Function timeLoadString_Read() As Integer
  Return (DateDiff($timeStartLoadString, $timeEndLoadString, gb.Millisecond))
End
Private Function timeLoadFile_Read() As Integer
  Return (DateDiff($timeStartLoadFile, $timeEndLoadFile, gb.Millisecond))
End
Private Function timeBuildDOM_Read() As Integer
  Return (DateDiff($timeStartBuildDOM, $timeEndBuildDOM, gb.Millisecond))
End

Private Function classVersion_Read() As String
  Return $classVersion
End
Private Function classDescription_Read() As String
  Return $classDescription
End
Private Function className_Read() As String
  Return Object.Class(Me).Name
End
Private Function classVendor_Read() As String
  Return $classVendor
End

'**** Lo gordo de construir el DOM esta aqui ***
Private Sub initDom()
  $timeStartBuildDOM = Now
  
  If Me.readyState = True Then
    clearDom
    Me.readyState = False
  Endif

  parseDocument
  Me.readyState = True
  
  $timeEndBuildDOM = Now
End

Private Sub clearDom()
  ''TODO: Clear and initialize all objects

End

''****** FIN Constructores y Propiedades


''*** Metodos Publicos
Public Sub fromString(strHtml As String)
  $swLoadedByFile = False
  $timeStartLoadString = Now
  $innerHTML = strHtml
  $strHtml = strHtml
  $timeEndLoadString = Now
  initDom
End

Public Function fromFile(strFilepath As String) As Boolean
  Dim pF As File
  Dim strLine As String

  ''TODO: Missing "\n" whith Line Input. Must Repair. (***) Using LineEnds broke the DOM. Must Repair.
  If Exist(strFilepath) And Access(strFilepath, gb.Read) = True Then
    $swLoadedByFile = True
    $timeStartLoadFile = Now
	
    pF = Open strFilepath For Input
    While Not Eof(pF)
      Line Input #pF, strLine
      $strHtml &= strLine
    Wend
    Close #pF

    $timeEndLoadFile = Now
    initDom
    Return True
  Endif

  Return False
End

Public Function objectStats(Optional printIt As Boolean = True) As String
	Dim strRet As String = ""
	
	strRet &= "**************** " & Object.Class(Me).Name & " Time Statistics ****************\n"
	If $swLoadedByFile = True Then
	  strRet &= "\tTime to load File:\t" & (Me.timeLoadFile / 1000) & " Seconds.\n"
	Else
	  strRet &= "\tTime to load String:\t" & (Me.timeLoadString / 1000) & " Seconds.\n"
	Endif
	strRet &= "\tTime to Build DOM:\t" & (Me.timeBuildDOM / 1000) & " Seconds.\n"
	strRet &= "*************************************************************\n\n"
	
	If printIt = True Then Print strRet
	
	Return strRet
End

'***Finding HTML HTMElements
Public Function getElementById(id As String) As HTMElement

End

Public Function getElementsByTagName(name As String) As HTMElement[]

End

Public Function getElementsByName(name As String) As HTMElement[]

End

Public Function getElementsByClassName(name As String) As HTMElement[]

End

Public Function querySelectorAll(strCSSSelector As String) As HTMElement[]

End

'***Adding and Deleting HTMElements
Public Function createElement(obElm As HTMElement) As Boolean

End

Public Function createTextNode(STR As String) As HTMElement

End

Public Function removeChild(obElm As HTMElement) As Boolean

End

Public Function appendChild(obElm As HTMElement) As Boolean

End

Public Function replaceChild(obElm As HTMElement) As Boolean

End

Public Function write(text As String) As Boolean

End



''*********** INICIO PARSERS ****************
Private Sub parseDocument()
  Dim i As Integer = 0, j As Integer = 0, nTotTam As Integer = 0, currentPos As Integer = 0, auxPos1 As Integer = 0, auxPos2 As Integer = 0
  Dim auxStr As String, auxStrTagName As String
  Dim swStartParse As Boolean = False

  nTotTam = Len($strHtml)

  currentPos = InStr($strHtml, "<", 1)  ''Consume los espacios y basura hasta llegar al primer tag.

  For i = currentPos To nTotTam
    If Mid$($strHtml, i, 1) = "<" Then
      auxStrTagName = parseGetTagName(i)
      If parseIsDoctype(auxStrTagName) = True Then
        i = parseDocType(i) 		''Returns where parsing ends, so we continue after
      Else If parseIsComment(auxStrTagName) = True Then
        i = parseComment(i) 	''Returns where parsing ends, so we continue after
      Else If parseIsText(auxStrTagName) = True Then
        i = parseText(i) 			''Returns where parsing ends, so we continue after
      Else If parseIsHtml(auxStrTagName) Then
        i = parseElement(i, True) 	''Returns where parsing ends, so we continue after
      Else
        i = parseElement(i) 	''Returns where parsing ends, so we continue after
      Endif
    Endif
  Next

End

Private Function parseElement(strPos As Integer, Optional isRoot As Boolean = False) As Integer
  Dim endPos As Integer = 0, startChildPos As Integer = 0
  Dim i As Integer, j As Integer
  Dim auxStr As String, auxStrTagName As String, arrAuxAttr As Collection
  Dim actualElm As HTMElement, actualElmIdx As Integer = 0

  Dim arrAuxElems As HTMElement[]

  auxStrTagName = parseGetTagName(strPos)
  
  If Left$(auxStrTagName, 1) = "/" Then ''Ignore Close Tag
    Return (InStr($strHtml, ">", strPos) + 1)
  Endif
  
  If parseIsComment(auxStrTagName) = True Then
    endPos = parseComment(strPos) 		''Returns where parsing ends, so we continue after
  Else If parseIsText(auxStrTagName) = True Then
    endPos = parseText(strPos) 			''Returns where parsing ends, so we continue after
  Else 	'' Here we arrive when dealing wtih common tags.
    auxStr = parseGetEtiquetaCompleta(strPos, ByRef endPos) ''Returns Byref the endPos(End Posittion) of the Tag.
    arrAuxAttr = parseGetAttribs(auxStr)

    $all.Add(Null)
    $all[$all.Count - 1] = New HTMElement("")
    actualElm = $all[$all.Count - 1]
    If isRoot Then 	''<html> Tag
      Me.root = $all[$all.Count - 1]
      Me.documentElement = Me.root
    Endif

    '' *** HTMElement Props.
    actualElm.tagName = auxStrTagName
    If actualElm.tagName Then
      If $tagNames.Exist(actualElm.tagName) = False Then
        arrAuxElems = New HTMElement[]
        arrAuxElems.Add(actualElm)
        $tagNames.Add(arrAuxElems.Copy(0, arrAuxElems.Count), actualElm.tagName)
      Else
        $tagNames[actualElm.tagName].Add(actualElm)
      Endif
    Endif

    actualElm.id = arrAuxAttr["id"]
    If arrAuxAttr["id"] Then
      If $ids.Exist(arrAuxAttr["id"]) = False Then
        arrAuxElems = New HTMElement[]
        arrAuxElems.Add(actualElm)
        $ids.Add(arrAuxElems.Copy(0, arrAuxElems.Count), arrAuxAttr["id"])
      Else
        $ids[arrAuxAttr["id"]].Add(actualElm)
      Endif
    Endif

    actualElm.name = arrAuxAttr["name"]
    If arrAuxAttr["name"] Then
      If $names.Exist(arrAuxAttr["name"]) = False Then
        arrAuxElems = New HTMElement[]
        arrAuxElems.Add(actualElm)
        $names.Add(arrAuxElems.Copy(0, arrAuxElems.Count), arrAuxAttr["name"])
      Else
        $names[arrAuxAttr["name"]].Add(actualElm)
      Endif
    Endif

    actualElm.class = arrAuxAttr["class"]
    If arrAuxAttr["class"] Then
      If $classNames.Exist(arrAuxAttr["class"]) = False Then
        arrAuxElems = New HTMElement[]
        arrAuxElems.Add(actualElm)
        $classNames.Add(arrAuxElems.Copy(0, arrAuxElems.Count), arrAuxAttr["class"])
      Else
        $classNames[arrAuxAttr["class"]].Add(actualElm)
      Endif
    Endif

    actualElm.style = arrAuxAttr["style"]
    actualElm.type = arrAuxAttr["type"]
    actualElm.nodeType = parseGetElementType(actualElm.tagName)
    actualElm.nodeValue = Null 		''for element nodes is undefined. or text nodes is the text itself. or attribute nodes is the attribute value.

    ''**** Don't remove this attributes. So we can get them by two methods (By the property and by the attributes collection).
    '~ arrAuxAttr.Remove("id")
    '~ arrAuxAttr.Remove("name")
    '~ arrAuxAttr.Remove("class")
    '~ arrAuxAttr.Remove("style")
    '~ arrAuxAttr.Remove("type")
    actualElm.attributes = arrAuxAttr.Copy()

    ''**** INICIO Element DOM References
    If isRoot Then 	''<html> Tag
      actualElm.parentNode = Null
      actualElm.nextSibling = Null
      actualElm.previousSibling = Null
  
	  $stackElm.Add(actualElm)  ''First Parent of the DOM
    Endif
    If $stackElm.Count > 0 And actualElm.tagName <> "html" Then
      actualElm.parentNode = $stackElm[$stackElm.Count - 1]
      If actualElm.parentNode.firstChild = Null Then
        actualElm.parentNode.firstChild = actualElm
      Endif
      actualElm.parentNode.lastChild = actualElm

      actualElm.parentNode.childNodes.Add(actualElm)

      actualElmIdx = actualElm.parentNode.childNodes.Find(actualElm)
      If actualElmIdx > 0 Then
        actualElm.previousSibling = actualElm.parentNode.childNodes[actualElmIdx - 1]
      Endif
      If actualElmIdx < (actualElm.parentNode.childNodes.Count - 1) Then
        actualElm.nextSibling = actualElm.parentNode.childNodes[actualElmIdx + 1]
      Endif
    Endif
    
    ''**** References
    Select actualElm.tagName
      Case "head"
        Me.head = actualElm
      Case "title"
        Me.title = actualElm
      Case "body"
        Me.body = actualElm
      Case "a"
        If actualElm.name Then Me.anchors.Add(actualElm)
        If actualElm.attributes["href"] Then Me.links.Add(actualElm)
      Case "applet"
        Me.applets.Add(actualElm)
      Case "embed"
        Me.embeds.Add(actualElm)
      Case "form"
        Me.forms.Add(actualElm)
      Case "img"
        Me.images.Add(actualElm)
      Case "script"
        Me.scripts.Add(actualElm)
      Case "meta"
        Me.metas.Add(actualElm)
      Case "link"
        Me.linkRels.Add(actualElm)
        If actualElm.attributes["rel"] And InStr(actualElm.attributes["rel"], "icon", 0, gb.IgnoreCase) > 0 Then
          Me.favicon = actualElm
        Endif
    End Select
    ''**** FIN Element DOM References


    ''**** If there are Childs ....
    startChildPos = parseHasTextChild(actualElm.tagName, endPos)
    If startChildPos > 0 Then
      $stackElm.Add(actualElm) 	''To keep nesting track
      endPos = parseText(startChildPos) 	''Returns where parsing ends, so we continue after
      $stackElm.Remove($stackElm.Count - 1)
    Endif
    
    Do ''While has ChildTags
      startChildPos = parseHasTagChild(actualElm.tagName, endPos)
      If startChildPos > 0 Then
        $stackElm.Add(actualElm) 	''To keep nesting track
        endPos = parseElement(startChildPos) 	''Returns where parsing ends, so we continue after
        $stackElm.Remove($stackElm.Count - 1)
      Endif
    Loop Until startChildPos = 0
  Endif

  Return endPos
End

Private Sub parseDocType(strPos As Integer) As Integer
  Dim endPos As Integer = 0
  ''TODO: parseDocType
  Me.doctype = parseGetEtiquetaCompleta(strPos, ByRef endPos)

  Return endPos ''(**OJO**) Is returned by parseGetEtiquetaCompleta ByRef
End

Private Sub parseComment(strPos As Integer) As Integer
  Dim endPos As Integer = 0
  Dim lenStartTag As Integer = 4  ''Len("<!--")
  Dim actualElm As HTMElement
  Dim actualElmIdx As Integer
  
  '<!--...-->
  endPos = InStr($strHtml, "-->", strPos)
  
  $all.Add(Null)
  $all[$all.Count - 1] = New HTMElement("")
  actualElm = $all[$all.Count - 1]
  Me.comments.Add(actualElm)
  
  actualElm.nodeValue = Mid$($strHtml, strPos + lenStartTag, (endPos - strPos - lenStartTag))
  actualElm.nodeType = Me.NODETYPE_COMMENT
  
  If $stackElm.Count > 0 Then
    actualElm.parentNode = $stackElm[$stackElm.Count - 1]
    If actualElm.parentNode.firstChild = Null Then
      actualElm.parentNode.firstChild = actualElm
    Endif
    actualElm.parentNode.lastChild = actualElm
  
    actualElm.parentNode.childNodes.Add(actualElm)
  
    actualElmIdx = actualElm.parentNode.childNodes.Find(actualElm)
    If actualElmIdx > 0 Then
      actualElm.previousSibling = actualElm.parentNode.childNodes[actualElmIdx - 1]
    Endif
    If actualElmIdx < (actualElm.parentNode.childNodes.Count - 1) Then
      actualElm.nextSibling = actualElm.parentNode.childNodes[actualElmIdx + 1]
    Endif
  Endif

  Return endPos
End

Private Sub parseText(strPos As Integer) As Integer ''Parser for TEXT and SCRIPTS content.
  Dim endPos As Integer = 0, startTagSibilingPos As Integer = 0
  Dim actualElm As HTMElement
  Dim actualElmIdx As Integer
  
  $all.Add(Null)
  $all[$all.Count - 1] = New HTMElement("")
  actualElm = $all[$all.Count - 1]
  
  If $stackElm.Count > 0 Then
    actualElm.parentNode = $stackElm[$stackElm.Count - 1]
    If actualElm.parentNode.firstChild = Null Then
      actualElm.parentNode.firstChild = actualElm
    Endif
    actualElm.parentNode.lastChild = actualElm
  
    actualElm.parentNode.childNodes.Add(actualElm)
  
    actualElmIdx = actualElm.parentNode.childNodes.Find(actualElm)
    If actualElmIdx > 0 Then
      actualElm.previousSibling = actualElm.parentNode.childNodes[actualElmIdx - 1]
    Endif
    If actualElmIdx < (actualElm.parentNode.childNodes.Count - 1) Then
      actualElm.nextSibling = actualElm.parentNode.childNodes[actualElmIdx + 1]
    Endif
  Endif

  If actualElm.parentNode.tagName = "script" Then
    endPos = InStr($strHtml, "</script>", strPos)
	actualElm.nodeValue = Mid$($strHtml, strPos, (endPos - strPos))
	Me.scripts.Add(actualElm)
	endPos += 9 ''Len("</script>")
  Else
    endPos = InStr($strHtml, "<", strPos)
	actualElm.nodeValue = Mid$($strHtml, strPos, (endPos - strPos))
	Me.texts.Add(actualElm)
  Endif
  
  actualElm.nodeType = Me.NODETYPE_TEXT
  
  If actualElm.parentNode.tagName <> "script" Then
    startTagSibilingPos = parseHasTagSibiling(endPos)
    If startTagSibilingPos > 0 Then ''Return 0 if NOT, >0 is the start Possition
      endPos = parseElement(startTagSibilingPos)
    Endif
  Endif
  
  ''TODO: parseText --> Parser for TEXT and SCRIPTS content. See if Right
  Return endPos
End

Private Function parseGetAttribs(strEtiqueta As String) As Collection
  Dim ntam As Integer = 0
  Dim auxStr As String, sAux1 As String, arrAux As String[], auxArrKeyVal As String[], arrRet As New Collection

  auxStr = _HUtil.utilTrim(strEtiqueta, [" ", "\n", "<", ">"])
  arrAux = _HUtil.utilSplit(auxStr, " ", ["\"", "'"])

  arrAux.Remove(0) ' Quitar el TagName

  For Each sAux1 In arrAux
    auxArrKeyVal = _HUtil.utilSplit(sAux1, "=", ["\"", "'"])
    If auxArrKeyVal.Count > 1 Then
      arrRet[Trim(auxArrKeyVal[0])] = _HUtil.utilTrim(auxArrKeyVal[1], [" ", "\""])
    Else
      arrRet[Trim(auxArrKeyVal[0])] = ""
    Endif
  Next

  Return arrRet
End

Private Function parseGetEtiquetaCompleta(strPos As Integer, ByRef endPos As Integer) As String
  endPos = InStr($strHtml, ">", strPos)
  Return Mid$($strHtml, strPos, (endPos - (strPos)))
End

Private Function parseGetTagName(strPos As Integer) As String

  Dim spcPos As Integer, closePos As Integer

  spcPos = InStr($strHtml, " ", strPos + 1)
  closePos = InStr($strHtml, ">", strPos + 1)
  If closePos < spcPos Then
    Return LCase$(Mid$($strHtml, strPos + 1, (InStr($strHtml, ">", strPos + 1) - (strPos + 1))))
  Endif
  Return LCase$(Mid$($strHtml, strPos + 1, (InStr($strHtml, " ", strPos + 1) - (strPos + 1))))

End

Private Function parseIsHtml(strTagName As String) As Boolean
  If LCase$(strTagName) = "html" Then Return True
  Return False
End

Private Function parseIsDoctype(strTagName As String) As Boolean

  If LCase$(strTagName) = "!doctype" Then Return True
  Return False

End

Private Function parseIsComment(strTagName As String) As Boolean

  If Left$(strTagName, 3) = "!--" Then Return True
  Return False

End 

Private Function parseIsText(strTagName As String) As Boolean
  ''TODO: parseIsText. See if Correct.
  If Len(Trim(strTagName)) = 0 Then Return True
  Return False
End

Private Function parseHasTextChild(tagName As String, endTagPos As Integer) As Integer ''Return 0 if NOT, >0 is the start Possition
  Dim iniNewTagPos As Integer = 0
  Dim actualElm As HTMElement
  
  If tagName = "script" Then
    iniNewTagPos = InStr($strHtml, "</script>", endTagPos)  'Open tag
    If iniNewTagPos > 0 Then iniNewTagPos += 9 ''Len("</script>")
  Else
    iniNewTagPos = InStr($strHtml, "<", endTagPos)  'Open tag
  Endif
  
  If iniNewTagPos > (endTagPos + 1) Then ''There is Text Child
    Return (endTagPos + 1)
  Endif
  Return 0 ''No Text Child
End

Private Function parseHasTagChild(tagName As String, strPos As Integer) As Integer ''Return 0 if NOT, >0 is the start Possition
  Dim endPos As Integer = 0
  ''TODO: parseHasTagChild
  If Len(Trim(tagName)) = 0 Then Return 0 ''No TagChild cause is text
  If tagName = "script" Then Return 0 ''No TagChild cause is script
  
  If Me.tagCanHaveChild(tagName) = False Then Return 0 ''If can not have tagChild ...
  
  endPos = InStr($strHtml, "<", strPos)  'Open tag
  
  Return endPos
End

Private Function parseHasTagSibiling(strPos As Integer) As Integer ''Return 0 if NOT, >0 is the start Possition
  Dim endPos As Integer = 0
  
  Return endPos
End

Private Function parseFindCloseTag(strPos As Integer) As Integer ''Return 0 if NOT, >0 is the END Possition
  ''TODO: parseFindCloseTag
  Return 0
End

Private Function parseGetElementType(strTagName As String) As Byte
  ''**** Tipos de elementos: http://www.w3schools.com/jsref/prop_node_nodetype.asp
  ' Element		1
  ' Attribute		2
  ' Text			3
  ' Comment		8
  ' Document	9

  ''TODO: parseGetElementType

  Return 1
End

''*********** FIN PARSERS ****************






