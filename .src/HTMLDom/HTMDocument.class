' Gambas class file

Inherits _HTMCONSTS

Export


''http://www.w3schools.com/js/js_htmldom.asp

''Propiedades publicas
Property innerHTML As String
Private $innerHTML As String
Property text As String
Private $text As String

Private $strHtml As String '' *** Esta es la que se usa para el parser
Private $removeBlankText As Boolean = False

''*** INICIO Time Measurements
Private $swLoadedByFile as Boolean=False
Private $timeStartLoadString as Date
Private $timeEndLoadString as Date
Property Read timeLoadString as Integer
Private $timeStartLoadFile as Date
Private $timeEndLoadFile as Date
Property Read timeLoadFile as Integer
Private $timeStartBuildDOM as Date
Private $timeEndBuildDOM as Date
Property Read timeBuildDOM as Integer
''*** FIN Time Measurements

''**** INICIO Coleccion para busquedas
Private $all As New HTMElement[]
Private $ids As New Collection '' HTMElement[]
Private $tagNames As New Collection '' HTMElement[][]
Private $names As New Collection '' HTMElement[][]
Private $classNames As New Collection '' HTMElement[][]
''**** FIN Coleccion para busquedas

Private $stackElm As New HTMElement[] 		''To keep nesting track

Public document As HTMDocument = Me

Public readyState As Boolean = False      'Returns the(loading)status Of the document 3
Public strictErrorChecking As Boolean = False     'Returns If Error checking Is Enforced 3

Public root As HTMElement = Null 		'Same as documentElement ---> '<html>'
Public documentElement As HTMElement = Null      'Returns the < html > HTMElement 3
Public head As HTMElement = Null      'Returns the < head > HTMElement 1
Public favicon As HTMElement = Null 		'<link rel="shortcut icon" type="image/png" href="http://eg.com/favicon.png"/>
Public title As HTMElement = Null      'Returns the < title > HTMElement 1
Public body As HTMElement = Null      'Returns the < body > HTMElement 1
Public cookie As New HTMElement[]      'Returns the document 's cookie 	1 (**)NOT IMPLEMENTED as JavaScript is not implemente in this DOM tree.
Public anchors As New HTMElement[]      'Returns all < a > HTMElements that have a name attribute 1
Public applets As New HTMElement[]      'Returns all < applet > HTMElements(Deprecated In HTML5)1
Public embeds As New HTMElement[]      'Returns all < embed > HTMElements 3
Public forms As New HTMElement[]      'Returns all < form > HTMElements 1
Public images As New HTMElement[]      'Returns all < img > HTMElements 1
Public links As New HTMElement[]      'Returns all < area > And < a > HTMElements that have a href attribute 1
Public metas As New HTMElement[]      'Returns all < meta > HTMElements
Public linkRels As New HTMElement[]      'Returns all < link > HTMElements
Public scripts As New HTMElement[]      'Returns all < script > HTMElements 3


Public baseURI As String      'Returns the absolute base URI Of the document 3
Public doctype As String      'Returns the document 's doctype 	3
Public documentMode As String     'Returns the mode used by the browser 3
Public documentURI As String      'Returns the URI Of the document 3
Public domain As String       'Returns the domain name Of the document server 1
Public domConfig As String 'Obsolete.Returns the DOM configuration 3
Public implementation As String     'Returns the DOM implementation 3
Public inputEncoding As String      'Returns the document 's encoding (character set) 	3
Public lastModified As String      'Returns the Date And Time the document was updated 3
Public referrer As String      'Returns the URI Of the referrer(the linking document)1
Public URL As String      'Returns the complete URL Of the document 1


''****** INICIO Constructores y Propiedades
Public Sub _new(Optional strHtml As String = Null, Optional removeBlankText As Boolean = False)
  $removeBlankText = removeBlankText
  
  If strHtml <> Null Then
	$swLoadedByFile=False
	$timeStartLoadString=Now
    $innerHTML = strHtml
    $strHtml = strHtml
	$timeEndLoadString=Now
    initDom
  Endif

End

Private Function innerHTML_Read() As String
  Return $innerHTML
End

Private Sub innerHTML_Write(Value As String)
  $swLoadedByFile=False
  $timeStartLoadString=Now
  $innerHTML = Value
  $strHtml = Value
  $timeEndLoadString=Now
  initDom
End

Private Function text_Read() As String
  Return $Text
End

Private Sub text_Write(Value As String)
  $text = Value
  $innerHTML = Value
  $strHtml = Value
  initDom
End

Private Function timeLoadString_Read() As Integer
  Return (DateDiff ($timeStartLoadString, $timeEndLoadString, gb.Millisecond))
End
Private Function timeLoadFile_Read() As Integer
  Return (DateDiff ($timeStartLoadFile, $timeEndLoadFile, gb.Millisecond))
End
Private Function timeBuildDOM_Read() As Integer
  Return (DateDiff ($timeStartBuildDOM, $timeEndBuildDOM, gb.Millisecond))
End

'**** Lo gordo de construir el DOM esta aqui ***
Private Sub initDom()
  $timeStartBuildDOM=Now
  
  If Me.readyState = True Then
    clearDom
    Me.readyState = False
  Endif

  parseDocument
  Me.readyState = True
  
  $timeEndBuildDOM=Now
End

Private Sub clearDom()
  ''TODO: Clear and initialize all objects

End

''****** FIN Constructores y Propiedades


''*** Metodos Publicos
Public Sub fromString(strHtml As String)
  $swLoadedByFile=False
  $timeStartLoadString=Now
  $innerHTML = strHtml
  $strHtml = strHtml
  $timeEndLoadString=Now
  initDom
End

Public Function fromFile(strFilepath As String) As Boolean
  Dim pF As File
  Dim strLine As String

  If Exist(strFilepath) And Access(strFilepath, gb.Read) = True Then
    $swLoadedByFile=True
    $timeStartLoadFile=Now
	
    pF = Open strFilepath For Input
    While Not Eof(pF)
      Line Input #pF, strLine
      $strHtml &= strLine
    Wend
    Close #pF

    $timeEndLoadFile=Now
    Return True
  Endif

  Return False
End

Public Function getTimeStats(Optional printIt as Boolean=True) As String
	Dim strRet as String=""
	
	strRet &="**************** " & Object.Class(Me).Name & " Time Statistics ****************\n"
	if $swLoadedByFile=True then
	  strRet &="\tTime to load File:\t" & (Me.timeLoadFile/1000) & " Seconds.\n"
	else
	  strRet &="\tTime to load String:\t" & (Me.timeLoadString/1000) & " Seconds.\n"
	EndIf
	strRet &="\tTime to Build DOM:\t" & (Me.timeBuildDOM/1000) & " Seconds.\n"
	strRet &="*************************************************************\n\n"
	
	if printIt=True Then Print strRet
	
	Return strRet
End

'***Finding HTML HTMElements
Public Function getElementById(id As String) As HTMElement

End

Public Function getElementsByTagName(name As String) As HTMElement[]

End

Public Function getElementsByName(name As String) As HTMElement[]

End

Public Function getElementsByClassName(name As String) As HTMElement[]

End

Public Function querySelectorAll(strCSSSelector As String) As HTMElement[]

End

'***Adding and Deleting HTMElements
Public Function createElement(obElm As HTMElement) As Boolean

End

Public Function createTextNode(STR As String) As HTMElement

End

Public Function removeChild(obElm As HTMElement) As Boolean

End

Public Function appendChild(obElm As HTMElement) As Boolean

End

Public Function replaceChild(obElm As HTMElement) As Boolean

End

Public Function write(text As String) As Boolean

End



''*********** INICIO PARSERS ****************
Private Sub parseDocument()
  Dim i As Integer = 0, j As Integer = 0, nTotTam As Integer = 0, currentPos As Integer = 0, auxPos1 As Integer = 0, auxPos2 As Integer = 0
  Dim auxStr As String, auxStrTagName As String
  Dim swStartParse As Boolean = False

  nTotTam = Len($strHtml)

  For i = 1 To nTotTam 	''Consume los espacios y basura hasta llegar al primer tag.
    If Mid$($strHtml, i, 1) = "<" Then
      swStartParse = True
      currentPos = i
      Break
    Endif
  Next

  For i = currentPos To nTotTam
    If Mid$($strHtml, i, 1) = "<" Then
      auxStrTagName = parseGetTagName(i)
      If parseIsDoctype(auxStrTagName) = True Then
        i = parseDocType(i) 		''Returns where parsing ends, so we continue after
      Else If parseIsComment(auxStrTagName) = True Then
        i = parseComment(i) 	''Returns where parsing ends, so we continue after
      Else If parseIsText(auxStrTagName) = True Then
        i = parseText(i) 			''Returns where parsing ends, so we continue after
      Else If parseIsHtml(auxStrTagName) Then
        i = parseElement(i, True) 	''Returns where parsing ends, so we continue after
      Else
        i = parseElement(i) 	''Returns where parsing ends, so we continue after
      Endif
    Endif
  Next

End

'~ 		Private $all As HTMElement[]
'~ 		Private $ids As HTMElement[]
'~ 		Private $tagNames As HTMElement[][]
'~ 		Private $names As HTMElement[][]
'~ 		Private $classNames As HTMElement[][]


Private Sub parseElement(strPos As Integer, Optional isRoot As Boolean = False) As Integer
  Dim endPos As Integer = 0, startChildPos As Integer = 0
  Dim i As Integer, j As Integer
  Dim auxStr As String, auxStrTagName As String, arrAuxAttr As Collection
  Dim actualElm As HTMElement, actualElmIdx As Integer = 0

  Dim arrAuxElems As HTMElement[]

  auxStrTagName = parseGetTagName(strPos)
  If parseIsComment(auxStrTagName) = True Then
    endPos = parseComment(strPos) 		''Returns where parsing ends, so we continue after
  Else If parseIsText(auxStrTagName) = True Then
    endPos = parseText(strPos) 			''Returns where parsing ends, so we continue after
  Else 	'' Here we arrive when dealing wtih common tags.
    auxStr = parseGetEtiquetaCompleta(strPos, ByRef endPos) ''Returns Byref the endPos(End Posittion) of the Tag.
    arrAuxAttr = parseGetAttribs(auxStr)

    $all.Add(Null)
    $all[$all.Count - 1] = New HTMElement("")
    actualElm = $all[$all.Count - 1]
    If isRoot Then 	''<html> Tag
      Me.root = $all[$all.Count - 1]
      Me.documentElement = Me.root
    Endif

    '' *** HTMElement Props.
    actualElm.tagName = parseGetTagName(strPos)
    If actualElm.tagName Then
      If $tagNames.Exist(actualElm.tagName) = False Then
        arrAuxElems = New HTMElement[]
        arrAuxElems.Add(actualElm)
        $tagNames.Add(arrAuxElems.Copy(0, arrAuxElems.Count), actualElm.tagName)
      Else
        $tagNames[actualElm.tagName].Add(actualElm)
      Endif
    Endif

    actualElm.id = arrAuxAttr["id"]
    If arrAuxAttr["id"] Then
      If $ids.Exist(arrAuxAttr["id"]) = False Then
        arrAuxElems = New HTMElement[]
        arrAuxElems.Add(actualElm)
        $ids.Add(arrAuxElems.Copy(0, arrAuxElems.Count), arrAuxAttr["id"])
      Else
        $ids[arrAuxAttr["id"]].Add(actualElm)
      Endif
    Endif

    actualElm.name = arrAuxAttr["name"]
    If arrAuxAttr["name"] Then
      If $names.Exist(arrAuxAttr["name"]) = False Then
        arrAuxElems = New HTMElement[]
        arrAuxElems.Add(actualElm)
        $names.Add(arrAuxElems.Copy(0, arrAuxElems.Count), arrAuxAttr["name"])
      Else
        $names[arrAuxAttr["name"]].Add(actualElm)
      Endif
    Endif

    actualElm.class = arrAuxAttr["class"]
    If arrAuxAttr["class"] Then
      If $classNames.Exist(arrAuxAttr["class"]) = False Then
        arrAuxElems = New HTMElement[]
        arrAuxElems.Add(actualElm)
        $classNames.Add(arrAuxElems.Copy(0, arrAuxElems.Count), arrAuxAttr["class"])
      Else
        $classNames[arrAuxAttr["class"]].Add(actualElm)
      Endif
    Endif

    actualElm.style = arrAuxAttr["style"]
    actualElm.type = arrAuxAttr["type"]
    actualElm.nodeType = parseGetElementType(actualElm.tagName)
    actualElm.nodeValue = Null 		''for element nodes is undefined. or text nodes is the text itself. or attribute nodes is the attribute value.

    ''**** Don't remove this attributes. So we can get them by two methods (By the property and by the attributes collection).
    '~ arrAuxAttr.Remove("id")
    '~ arrAuxAttr.Remove("name")
    '~ arrAuxAttr.Remove("class")
    '~ arrAuxAttr.Remove("style")
    '~ arrAuxAttr.Remove("type")
    actualElm.attributes = arrAuxAttr.Copy()

    ''**** INICIO Element DOM References
    If isRoot Then 	''<html> Tag
      actualElm.parentNode = Null
      actualElm.nextSibling = Null
      actualElm.previousSibling = Null
    Endif
    If $stackElm.Count > 0 Then
      actualElm.parentNode = $stackElm[$stackElm.Count - 1]
      If actualElm.parentNode.firstChild = Null Then
        actualElm.parentNode.firstChild = actualElm
      Endif
      actualElm.parentNode.lastChild = actualElm

      actualElm.parentNode.childNodes.Add(actualElm)

      actualElmIdx = actualElm.parentNode.childNodes.Find(actualElm)
      If actualElmIdx > 0 Then
        actualElm.previousSibling = actualElm.parentNode.childNodes[actualElmIdx - 1]
      Endif
      If actualElmIdx < (actualElm.parentNode.childNodes.Count - 1) Then
        actualElm.nextSibling = actualElm.parentNode.childNodes[actualElmIdx + 1]
      Endif
    Endif
    ''**** References
    '~ 		Public parentNode As HTMElement
    '~ 		Public childNodes As HTMElement[]
    '~ 		Public firstChild As HTMElement
    '~ 		Public lastChild As HTMElement
    '~ 		Public nextSibling As HTMElement
    '~		 Public previousSibling As HTMElement


    '~ 		Public root As HTMElement		'Same as documentElement ---> '<html>'
    '~ 		Public documentElement As HTMElement      'Returns the < html > HTMElement 3
    '~ 		Public head As HTMElement      'Returns the < head > HTMElement 1
    '~		 Public title As HTMElement      'Returns the < title > HTMElement 1
    '~		 Public body As HTMElement      'Returns the < body > HTMElement 1
    '~ Public cookie As HTMElement[]      'Returns the document 's cookie 	1
    '~ 		Public anchors As HTMElement[]      'Returns all < a > HTMElements that have a name attribute 1
    '~ 		Public applets As HTMElement[]      'Returns all < applet > HTMElements(Deprecated In HTML5)1
    '~		Public embeds As HTMElement[]      'Returns all < embed > HTMElements 3
    '~ 		Public forms As HTMElement[]      'Returns all < form > HTMElements 1
    '~ 		Public images As HTMElement[]      'Returns all < img > HTMElements 1
    '~ 		Public links As HTMElement[]      'Returns all < area > And < a > HTMElements that have a href attribute 1
    '~ 		Public scripts As HTMElement[]      'Returns all < script > HTMElements 3
    '~ 		Public metas As New Collection '' HTMElement[]      'Returns all < meta > HTMElements
    '~ 		Public linkRels As New Collection '' HTMElement[]      'Returns all < link > HTMElements
    '~		Public favicon As HTMElement=Null		'<link rel="shortcut icon" type="image/png" href="http://eg.com/favicon.png"/>

    Select actualElm.tagName
      Case "head"
        Me.head = actualElm
      Case "title"
        Me.title = actualElm
      Case "body"
        Me.body = actualElm
      Case "a"
        If actualElm.name Then Me.anchors.Add(actualElm)
        If actualElm.attributes["href"] Then Me.links.Add(actualElm)
      Case "applet"
        Me.applets.Add(actualElm)
      Case "embed"
        Me.embeds.Add(actualElm)
      Case "form"
        Me.forms.Add(actualElm)
      Case "img"
        Me.images.Add(actualElm)
      Case "script"
        Me.scripts.Add(actualElm)
      Case "meta"
        Me.metas.Add(actualElm)
      Case "link"
        Me.linkRels.Add(actualElm)
        If actualElm.attributes["rel"] And InStr(actualElm.attributes["rel"], "icon", 0, gb.IgnoreCase) > 0 Then
          Me.favicon = actualElm
        Endif
    End Select
    ''**** FIN Element DOM References


    ''**** If there are Childs ....
    If (startChildPos = parseHasTextChild(endPos)) > 0 Then
      $stackElm[$stackElm.Count] = actualElm 	''To keep nesting track
      endPos = parseText(startChildPos) 	''Returns where parsing ends, so we continue after
      $stackElm.Remove($stackElm.Count)
    Else If (startChildPos = parseHasTagChild(endPos)) > 0 Then
      $stackElm[$stackElm.Count] = actualElm 	''To keep nesting track
      endPos = parseElement(startChildPos) 	''Returns where parsing ends, so we continue after
      $stackElm.Remove($stackElm.Count)
    Endif
  Endif

  Return endPos
End

Private Sub parseDocType(strPos As Integer) As Integer
  Dim endPos As Integer = 0
  ''TODO: parseDocType
  Me.doctype = parseGetEtiquetaCompleta(strPos, ByRef endPos)

  Return endPos
End

Private Sub parseComment(strPos As Integer) As Integer
  Dim endPos As Integer = 0
  ''TODO: parseComment
  Return endPos
End

Private Sub parseText(strPos As Integer) As Integer
  Dim endPos As Integer = 0
  ''TODO: parseText
  Return endPos
End

Private Function parseGetAttribs(strEtiqueta As String) As Collection
  Dim ntam As Integer = 0
  Dim auxStr As String, sAux1 As String, arrAux As String[], auxArrKeyVal As String[], arrRet As New Collection

  auxStr = utilTrim(strEtiqueta, [" ", "\n", "<", ">"])
  arrAux = utilSplit(auxStr, " ", ["\"", "'"])

  arrAux.Remove(0) ' Quitar el TagName

  ''TODO: El siguiente split corta por los = que hay dentro del valor del atributo. Hay que reparar.
  For Each sAux1 In arrAux
    auxArrKeyVal = utilSplit(sAux1, "=", ["\"", "'"])
    If auxArrKeyVal.Count > 1 Then
      arrRet[Trim(auxArrKeyVal[0])] = utilTrim(auxArrKeyVal[1], [" ", "\""])
    Else
      arrRet[Trim(auxArrKeyVal[0])] = ""
    Endif
  Next

  Return arrRet
End

Private Function parseGetEtiquetaCompleta(strPos As Integer, ByRef endPos As Integer) As String
  endPos = InStr($strHtml, ">", strPos)
  Return Mid$($strHtml, strPos, (endPos - (strPos)))
End

Private Function parseGetTagName(strPos As Integer) As String

  Dim spcPos As Integer, closePos As Integer

  spcPos = InStr($strHtml, " ", strPos + 1)
  closePos = InStr($strHtml, ">", strPos + 1)
  If closePos < spcPos Then
    Return LCase$(Mid$($strHtml, strPos + 1, (InStr($strHtml, ">", strPos + 1) - (strPos + 1))))
  Endif
  Return LCase$(Mid$($strHtml, strPos + 1, (InStr($strHtml, " ", strPos + 1) - (strPos + 1))))

End

Private Function parseIsHtml(strTagName As String) As Boolean
  If LCase$(strTagName) = "html" Then Return True
  Return False
End

Private Function parseIsDoctype(strTagName As String) As Boolean

  If LCase$(strTagName) = "!doctype" Then Return True
  Return False

End

Private Function parseIsComment(strTagName As String) As Boolean

  If Left$(strTagName, 3) = "!--" Then Return True
  Return False

End

Private Function parseIsText(strTagName As String) As Boolean
  ''TODO: parseIsText
  Return False
End

Private Function parseHasTextChild(endTagPos As Integer) As Integer ''Return 0 if NOT, >0 is the start Possition
  Dim iniNewTagPos As Integer = 0

  iniNewTagPos = InStr($strHtml, "<", endTagPos)  'Open tag
  If iniNewTagPos > (endTagPos + 1) Then ''There is Text Child
    Return (endTagPos + 1)
  Endif
  Return 0 ''No Text Child
End

Private Function parseHasTagChild(strPos As Integer) As Integer ''Return 0 if NOT, >0 is the start Possition
  ''TODO: parseHasTagChild
End

Private Function parseFindCloseTag(strPos As Integer) As Integer ''Return 0 if NOT, >0 is the END Possition
  ''TODO: parseFindCloseTag
End

Private Function parseGetElementType(strTagName As String) As Byte
  ''**** Tipos de elementos: http://www.w3schools.com/jsref/prop_node_nodetype.asp
  ' Element		1
  ' Attribute		2
  ' Text			3
  ' Comment		8
  ' Document	9

  ''TODO: parseGetElementType

  Return 1
End

''*********** FIN PARSERS ****************


''*********** INICIO UTILIDADES ****************
Private Function utilSplit(str As String, strSep as String, Optional notEnclosedIn as String[]=Null) As String[]
	Dim i as Integer, nTam as Integer, straAux as String, idxEnclosed as Integer=-1, strEnclosed as String="", strChar as String
	Dim arrRet As String[]
	
	if notEnclosedIn=Null then
		arrRet=Split(str, strSep, "", True)
	else
		nTam=Len(str)
		strAux=""
		for i=1 to nTam
			strChar=Mid$(str, i, 1)
			if strChar=strSep then
				if Len(strEnclosed)=0 then
					arrRet.Add(strAux)
					strAux=""
				else
					strAux &=strChar
				EndIf
			else if Len(strEnclosed)=0 and (idxEnclosed=notEnclosedIn.Find(strChar))>-1 then
				strEnclosed=notEnclosedIn[idxEnclosed]
			else if strEnclosed = strChar then
				strEnclosed=""
				idxEnclosed=-1
			else
				strAux &=strChar
			EndIf
		next
	Endif
	
	Return arrRet
End

Private Function utilTrim(strEtiqueta As String, arrStrTrimed As String[]) As String
  Dim i As Integer, j As Integer, nTam As Integer
  Dim strAux As String = "", strRet As String = ""

  nTam = Len(strEtiqueta)

  For i = 1 To nTam
    If arrStrTrimed.Find(Mid$(strEtiqueta, i, 1)) < 0 Then 	'Si se encuentra algun caracter que no hay que trimar ....
      strAux = Mid$(strEtiqueta, i)
      Break
    Endif
  Next

  nTam = Len(strAux)
  For i = 0 To nTam
    If arrStrTrimed.Find(Mid$(strAux, nTam - i, 1)) < 0 Then 	'Si se encuentra algun caracter que no hay que trimar ....
      strRet = Mid$(strAux, 1, nTam - i)
      Break
    Endif
  Next
  Return strRet
End
''*********** FIN UTILIDADES ****************



